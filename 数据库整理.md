
#数据库#
---  
## 触发器 
---
触发器是一中特殊的存储过程，主要是通过事件来触发而被执行的。它可以强化约束，
来维护数据的完整性和一致性，可以跟踪数据库内的操作从而不允许未经许可的更新和变
化。可以联级运算。如，某表上的触发器上包含对另一个表的数据操作，
而该操作又会导致该表触发器被触发。


**触发器的几种类型:**
>1. `before insert`  
2. `after insert`
3. `before update`
4. `after update`
5. `before delete`
6. `after delete  `
## 储存过程 ##
---
储存过程是一个预编译的sql语句，其优点是允许模块化的设计，一次创建多次调用  

**如何调用？**  



- 可以用一个命令对象来调用存储过程。


- 可以供外部程序调用，比如：java 程序。  
**优缺点**
*优点*
1. 存储过程是预编译过的，执行效率高
2. 存储过程的代码直接放在数据库中，通过储存名直接调用，减少网络通信
3. 安全性高，执行存储过程需要一定的用户权限
4. 存储过程可以重复使用，可减少开发人员的工作量
	  
*缺点*
1. 移植性差
  
## 索引  
---
索引是一种特殊的查询表，数据库可以利用他来加快查询速度    
**索引的优缺点**  
*缺点*  
减慢了数据录入的速度，同时也增加了数据库的尺寸大小

**什么样的字段适合索引**   

1. 经常被查询的字段
2. 不为空且字段不重复
3. 字段的值不经常被修改    

**索引的类型有哪些**  

1. **逻辑上**：单行索引，多行索引，唯一索引，非唯一索引，函数索引，域索引
2. **物理上**：分区索引，非分区索引  
3. **B-tree**:Normal 正常型 B 树，rever key 反转索引，Bitmap 位图索引  
  
  
##事物和锁##
---
**事务的ACID**:即原子性，一致性，隔离性，持久性  
**事物并发产生的问题**：脏读，不可重复读，幻读  
**事务的隔离级别**：未提交读，已提交读，可重复读，可串行化  （mysql默认的隔离级别是可重复读，跟其逻辑日志binlog有关）  

1. 读未提交 Read Uncommitted（在本次事务中可以读到其他事务中没有提交的数据-**脏数据**）
2. 读已提交 Read Committed （只能读到其他事务提交过的数据。如果在当前事务中，其他事务有提交，则两次读取结果不同，**造成不可重复读**） 
3. 可重复读 Repeatable Read （mysql默认，保证了事务中每次读取结果都相同，而不管其他事物是否已经提交。**会出现幻读**）
4. 序列化 Serializable （隔离级别中最严格的，开启一个serializable事务，那么其他事务对数据表的写操作都会被挂起）

**锁**：共享锁，排它锁，更新锁，意向锁  

1. **共享锁：**加了共享锁的数据对象可以被其他事务读取，但不能修改.`SELECT ... LOCK IN SHARE MODE;`
2. **排它锁：**当数据对象被加上排它锁时，其他的事务不能对它读取和修改。`SELECT ... FOR UPDATE;`
3. **更新锁：**防止通常形式的死锁。两个或多个事务获取资源的共享锁，试图同时更新数据，则两个事务都要获得排他锁，则事务之间等其他事务释放共享锁而造成死锁。使用更新锁可以避免这种情况。因为一次只有一个事务可以获得资源的更新锁，如果修改事务，则更新锁变为排它锁，否则变为共享锁
4. **意向锁：**意向锁是表级锁，其设计目的主要是为了在一个事务中揭示下一行将要被请求锁的类型。
>**意向排它锁**：表示事务准备给数据行加上排它锁，说明事务在加排它锁之前必须加上意向排他锁（IX）  
>**意向共享锁：**表示事务在准备给资源加上共享锁，也就是说一个数据行加共享锁前必须先取得该表的（意向共享锁）IS锁
  
- **乐观锁：**乐观锁假定在处理数据时，不需要在应用程序的代码中做任何事情就可以直接在记录上加锁、即完全依靠数据库来管理锁的工作。
- **悲观锁：**悲观锁对数据库系统的自动管理不感冒，需要程序员直接管理数据或对象上的加锁处理，并负责获取、共享和放弃正在使用的数据上的任何锁。    

**三级封锁协议**
>**一级锁协议：**  事务 T 要修改数据 A 时必须加 X 锁，直到 T 结束才释放锁（可以解决丢失修改问题，因为不能同时有两个事务对同一个数据进行修改，那么事务的修改就不会被覆盖。）  
>
>**二级锁协议：** 在一级的基础上，要求读取数据 A 时必须加 S 锁，读取完马上释放 S 锁。（可以解决读脏数据问题，因为如果一个事务在对数据 A 进行修改，根据 1 级封锁协议，会加 X 锁，那么就不能再加 S 锁了，也就是不会读入数据。）  
> 
>**三级锁协议：**在二级的基础上，要求读取数据 A 时必须加 S 锁，直到事务结束了才能释放 S 锁。（可以解决不可重复读的问题，因为读 A 时，其它事务不能对 A 加 X 锁，从而避免了在读的期间数据发生改变。）


 
## 视图和游标 ##
---
**视图：**视图是一种虚拟的表，具有和物理表相同的功能，可以对视图进行增删改查操作，视图通常是具有一个表或多个表的的行或列的子集，对视图的修改不影响物理表  
**游标：**对查询出来的结果集作为一个有效单元来处理，游标可以定在结果集的特定行，从结果集的当前行检索一行或多行  
**视图的优缺点:**  
***优点：***
>
- 对数据库的访问，因为视图可以有选择性的选取数据库里的一部分。
- 用户通过简单的查询可以从复杂查询中得到结果。
- 维护数据的独立性，试图可从多个表检索数据。
- 对于相同的数据可产生不同的视图。

***缺点：***
>性能：查询视图时，必须把视图的查询转化成对基本表的查询，如果这个视图是由一个
复杂的多表查询所定义，那么，即使是视图的一个简单查询，也把它变成一个复杂的结合体，
需要花费一定的时间。    
  
## 表的连接方式 ##
---
- 内连接、自连接、外连接（左、右、全）、交叉连接
- 内连接：只有两个元素表相匹配的才能在结果集中显示。
- **外连接：**
- 左外连接:左边为驱动表，驱动表的数据全部显示，匹配表的不匹配的不会显示。
- 右外连接:右边为驱动表，驱动表的数据全部显示，匹配表的不匹配的不会显示。
- 全外连接：连接的表中不匹配的数据全部会显示出来
- 交叉连接： 笛卡尔效应，显示的结果是链接表数的乘积。
在数据库中查询语句速度很慢，如何优化？
---
- 建索引
- 减少表之间的关联
- 优化 sql，尽量让 sql 很快定位数据，不要让 sql 做全表查询，应该走索引,把数据 量 大 的
表排在前面
- 简化查询字段，没用的字段不要，已经对返回结果的控制，尽量返回少量数据
尽量用 PreparedStatement 来查询，不要用 Statement
  

## 存储引擎 ##
---
InnoDB
--
是 MySQL 默认的事务型存储引擎，只有在需要它不支持的特性时，才考虑使用其它存储引擎。

实现了四个标准的隔离级别，默认级别是可重复读（REPEATABLE READ）。在可重复读隔离级别下，通过多版本并发控制（MVCC）+ 间隙锁（Next-Key Locking）防止幻影读。

主索引是聚簇索引，在索引中保存了数据，从而避免直接读取磁盘，因此对查询性能有很大的提升。

内部做了很多优化，包括从磁盘读取数据时采用的可预测性读、能够加快读操作并且自动创建的自适应哈希索引、能够加速插入操作的插入缓冲区等。

支持真正的在线热备份。其它存储引擎不支持在线热备份，要获取一致性视图需要停止对所有表的写入，而在读写混合场景中，停止写入可能也意味着停止读取。  
MyISAM
--
设计简单，数据以紧密格式存储。对于只读数据，或者表比较小、可以容忍修复操作，则依然可以使用它。

提供了大量的特性，包括压缩表、空间数据索引等。

不支持事务。

不支持行级锁，只能对整张表加锁，读取时会对需要读到的所有表加共享锁，写入时则对表加排它锁。但在表有读取操作的同时，也可以往表中插入新的记录，这被称为并发插入（CONCURRENT INSERT）。

可以手工或者自动执行检查和修复操作，但是和事务恢复以及崩溃恢复不同，可能导致一些数据丢失，而且修复操作是非常慢的。

如果指定了 DELAY_KEY_WRITE 选项，在每次修改执行完成时，不会立即将修改的索引数据写入磁盘，而是会写到内存中的键缓冲区，只有在清理键缓冲区或者关闭表的时候才会将对应的索引块写入磁盘。这种方式可以极大的提升写入性能，但是在数据库或者主机崩溃时会造成索引损坏，需要执行修复操作。  
比较
--
- 事务：InnoDB 是事务型的，可以使用 Commit 和 Rollback 语句。
- 并发：MyISAM 只支持表级锁，而 InnoDB 还支持行级锁。
- 外键：InnoDB 支持外键
- 备份：InnoDB 支持在线热备份。
- 崩溃恢复：MyISAM 崩溃后发生损坏的概率比 InnoDB 高很多，而且恢复的速度也更慢。
- 其它特性：MyISAM 支持压缩表和空间数据索引。

  